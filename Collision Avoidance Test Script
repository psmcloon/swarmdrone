#Generalized Collision Avoidance Distance
# import libraries
import RPi.GPIO as GPIO
import time
import numpy as np
# GPIO Modus (BOARD / BCM)
GPIO.setmode(GPIO.BCM)

if __name__ == '__main__':
    try:
        while True:
            droneLength = 0.26 #meters
            F = 17 #Pin 
            L = 26 #Pin
            R = 6 #Pin
            B = 16 #Pin
            front = distance(F)
            if front >= droneLength: 
                print ("move foward") 
            else if front < droneLength
                left = distance(L)
                right = distance(R)
                rear = distance(B)
                if left >= droneLength:
                    while front <= dronelength:
                        print("rotate left 1 degree") # Will rotate continuously until obstacle is no longer detected in path
                        front = distance(F) # Update while loop condition
                else if right >= droneLength:
                    while front <= droneLength:
                        Print("rotate right 1 degree")
                        front = distance(F) 
                else if rear >= dronelength:
                    left = distance(L)
                    right = distance(R)
                    while (left < droneLength and rear >= dronelength) or (right < droneLength and rear >= dronelength): # monitoring sides and rear while reversing
                        print("move backwards")
                        left = distance(L) 
                        right = distance(R) 
                    if left > droneLength:
                        front = distance(F)
                        while front < droneLength:
                            print("rotate left 1 degree")
                            front = distance(F)
                    else if right > droneLength :
                        while front < droneLength:
                            print("rotate right 1 degree")
                else
                    print("stuck")
                #Consideration made for changing altitude, experimentation required

                while (left < dronelength or right < droneLength) and front > droneLength: # Move forward to clear obstacle
                    front = distance(F) # Used to detect if there are additional obstacles in front
                    left = distance(L) # motitor current obstacle
                    right = distance(R) # motitor current obstacle
                    print("move foward")  
 
    except KeyboardInterrupt:
        print("Measurement stopped by user")
        GPIO.cleanup()
                          
                          
def distance(GPIOpin):#Sort distance according to GPIOpin, labeled as FOWARD, LEFT, RIGHT, and REAR in pseudocode 
    GPIO_SIG = GPIOpin;
    GPIO.setup(GPIO_SIG, GPIO.OUT)
    GPIO.output(GPIO_SIG, 0)

    time.sleep(0.000002)

    #send trigger signal
    GPIO.output(GPIO_SIG, 1)

    time.sleep(0.000005)

    GPIO.output(GPIO_SIG, 0)

    GPIO.setup(GPIO_SIG, GPIO.IN)

    while GPIO.input(GPIO_SIG) == 0:
        starttime = time.time()

    while GPIO.input(GPIO_SIG) == 1:
        endtime = time.time()
      
    duration = endtime - starttime
    # Distance is defined as time/2 (there and back) * speed of sound 34000 cm/s 
    distance = (duration*34000)/2/100 #return in meters
 
    return distance
