import numpy as np
#offset = 0
if __name__ == '__main__':
    try:
        while True:
            # Add lines here to pull rotation matrix as pose_r and translation matrix as pose_t
            
            pitch = np.arcsin(-pose_r[2,0]) # pitch dependent on tag orientation #Note: write as a function instead
            roll = np.arcsin(pose_r[2,1]/np.cos(pitch)) # roll depedent on tag orientation
            yaw = np.arcsin(pose_r[1,0]/np.cos(pitch))
            arr1 = np.array(pose_r)
            cpose_r = np.linalg.inv(arr1)
            cpose_t = np.array(-1*pose_t)
            tframepose_t = np.matmul(cpose_r, cpose_t)
            cframepose_t = -tframepose_t # Transfer origin back to drone
            yawarray = np.array([[np.cos(yaw), -np.sin(yaw), 0], [np.sin(yaw), np.cos(yaw), 0], [0, 0, 1]]) # define rotation matrix
            position = np.matmul(np.linalg.inv(yawarray), cframepose_t)
            
            # x coord: position[0], y coord: position[1], z coord: position[2], yaw: -yaw (check signs on yaw, might be wrong)
            GR_Dist = np.sqrt(position[0]**2 + position[1]**2) #total distance to travel
            GR_HDNG = -yaw #Heading/azimuth angle, clockwise position

            #global offset
            Distance threshold = 0 + #offset #Distance threshold, possibly can be increased if drone is stuck
            if position[2] == 0:
                print("Transition to Apriltag Search")
            #This current iteration does not account for the existence of the collision avoidance model.
            #Goal is to set heading equal to zero - likely through some form of PID control
            while GR_HDNG > 0: #Some consideration could be made for acceptable heading threshold/pid control
                difference = GR_HDNG - 0
                if np.sign(difference) > 0
                    print("Rotate right")
                else
                    print("Rotate left")
                pitch = np.arcsin(-pose_r[2,0]) # pitch dependent on tag orientation #Note: write as a function instead
                roll = np.arcsin(pose_r[2,1]/np.cos(pitch)) # roll depedent on tag orientation
                yaw = np.arcsin(pose_r[1,0]/np.cos(pitch))
                GR_HDNG = -yaw #Need to update this part
                    
            while GR_Dist > threshold: #Does not account for existence of collision avoidance script yet. Should transition to collision avoidance if an object is detected
                print("Move forward") #may want to set up a waypoint system, i.e saving the dist only at certain points rather than constantly. 
                GR_Dist = GR_Dist
                #if stuck: 
                    #offset = offset + 0.1    
                 #if GR_Dist <= threshold:
                    #offset = 0 #reset offset 
 
    except KeyboardInterrupt:
        print("Measurement stopped by user")
